import { useState, useRef, useEffect, useCallback, useMemo } from "react";
import { useNavigate } from "react-router-dom";
import { useDispatch, useSelector } from "react-redux";
import { Upload, Mail, Edit, Trash2, Info, Menu, X, Heart, Star, ShoppingCart, Bookmark, Package, Grid, List } from "lucide-react";
import ConfirmationDialogue from "../components/confirmationDialogue";
import NotificationItem from "../components/NotificationItem";
import EditNotificationModal from "../components/EditNotificationModal";
import usePushNotifications from "../hooks/usePushNotifications";
import { useUI } from "../store/hooks";
import { fcmService } from "../services/fcmService";

// Save For Later Redux imports (mock selectors for now)
const selectFilteredSaveForLaterItems = (state) => state.saveForLater?.items || [];
const selectSaveForLaterCount = (state) => state.saveForLater?.items?.length || 0;
const selectSaveForLaterLoading = (state) => state.saveForLater?.loading || false;
const selectSaveForLaterError = (state) => state.saveForLater?.error || null;
const selectSaveForLaterSortBy = (state) => state.saveForLater?.sortBy || 'dateAdded';
const selectSaveForLaterFilters = (state) => state.saveForLater?.filters || {};

// Mock Redux actions
const fetchSaveForLater = () => ({ type: 'saveForLater/fetch' });
const removeFromSaveForLaterAPI = (id) => ({ type: 'saveForLater/remove', payload: id });
const addToCart = (item) => ({ type: 'cart/add', payload: item });
const addToWishlist = (item) => ({ type: 'wishlist/add', payload: item });

// Static data moved outside component to prevent recreation on every render
const PLATFORM_OPTIONS = [
  { label: "Android", value: "android" },
  { label: "ios", value: "ios" },
];

const INITIAL_STACKED_NOTIFICATIONS = [
  { text: "Manage account and services linked to your Yoraa account" },
  { text: "Manage account and services linked to your Yoraa account" },
  { text: "Manage account and services linked to your Yoraa account" },
  { text: "Manage account and services linked to your Yoraa account" },
];

// PushNotification page for sending and managing notifications
// Features:
// - Compose notification text and deeplink
// - Select target platforms (multi-select)
// - Upload and preview notification image (with localStorage persistence)
// - Stack notification section with editable rows and popups
// - Uses NotificationItem and EditNotificationModal for modular UI
// Usage: Access via dashboard sidebar navigation
const PushNotification = () => {
  const dispatch = useDispatch();
  
  // Redux hooks for notifications
  const {
    currentNotification,
    stackedNotifications,
    isLoading,
    isSending,
    isUploading,
    error,
    uploadError,
    successMessage,
    updateNotification,
    resetNotification,
    sendNotificationWithValidation,
    uploadImage,
    saveForLater,
    updateStacked,
    removeFromScheduled,
    clearErrors,
    clearSuccessMessage,
    setPreviewImage,
    removePreviewImage,
    validateNotification,
    addNotification: addStackedNotification,
  } = usePushNotifications();

  // Redux selectors for Save For Later
  const saveForLaterItems = useSelector(selectFilteredSaveForLaterItems);
  const saveForLaterCount = useSelector(selectSaveForLaterCount);
  const saveForLaterLoading = useSelector(selectSaveForLaterLoading);
  const saveForLaterError = useSelector(selectSaveForLaterError);
  const sortBy = useSelector(selectSaveForLaterSortBy);
  const filters = useSelector(selectSaveForLaterFilters);

  const { addNotification } = useUI();

  // Local state for UI interactions
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [editIndex, setEditIndex] = useState(null);
  const [editValue, setEditValue] = useState("");
  const [dialogOpen, setDialogOpen] = useState(false);
  const [dialogAction, setDialogAction] = useState(null);
  const [selectedNotification, setSelectedNotification] = useState(null);
  const [selectedNotificationIndex, setSelectedNotificationIndex] = useState(null);
  
  // Save For Later state
  const [activeTab, setActiveTab] = useState('notifications');
  const [viewMode, setViewMode] = useState('grid');
  const [showFilters, setShowFilters] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [editingNote, setEditingNote] = useState(null);
  const [noteText, setNoteText] = useState('');
  const [selectedItems, setSelectedItems] = useState(new Set());

  // Reference for file input element
  const fileInputRef = useRef(null);

  // Navigation hook
  const navigate = useNavigate();

  // Initialize FCM service for receiving notifications
  useEffect(() => {
    const initializeFCM = async () => {
      try {
        const permission = await fcmService.requestPermission();
        if (permission) {
          console.log('FCM initialized successfully for push notifications page');
        }
      } catch (error) {
        console.warn('FCM initialization failed:', error);
      }
    };

    initializeFCM();
  }, []);

  // Show success/error messages using UI notifications
  useEffect(() => {
    if (successMessage) {
      addNotification({
        type: 'success',
        message: successMessage,
        duration: 3000,
      });
      clearSuccessMessage();
    }
  }, [successMessage, addNotification, clearSuccessMessage]);

  useEffect(() => {
    if (error || uploadError) {
      addNotification({
        type: 'error',
        message: error || uploadError,
        duration: 5000,
      });
      clearErrors();
    }
  }, [error, uploadError, addNotification, clearErrors]);

  // Memoized platform dropdown text to avoid recalculation on every render
  const platformDropdownText = useMemo(() => {
    const platforms = currentNotification.targetPlatform;
    if (platforms === 'both') return "android/ios";
    if (platforms === 'android') return "Android";
    if (platforms === 'ios') return "iOS";
    return "choose target platform";
  }, [currentNotification.targetPlatform]);

  // Optimized event handlers using useCallback to prevent unnecessary re-renders
  const handleFileUpload = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleFileChange = useCallback(async (e) => {
    const file = e.target.files[0];
    if (file) {
      // Set preview image
      const reader = new FileReader();
      reader.onload = (ev) => {
        setPreviewImage(ev.target.result);
      };
      reader.readAsDataURL(file);

      // Upload image to server
      const result = await uploadImage(file);
      if (result.success) {
        updateNotification({ imageUrl: result.imageUrl });
      }
    }
  }, [uploadImage, setPreviewImage, updateNotification]);

  const handleDropdownToggle = useCallback(() => {
    setDropdownOpen(prev => !prev);
  }, []);

  const handlePlatformSelect = useCallback((platform) => {
    updateNotification({ targetPlatform: platform });
    setDropdownOpen(false);
  }, [updateNotification]);

  const handleNavigateToPreview = useCallback(() => {
    navigate("/notification-preview", { 
      state: { 
        image: currentNotification.image || currentNotification.imageUrl,
        notification: currentNotification 
      } 
    });
  }, [navigate, currentNotification]);

  // Handle sending notification now
  const handleSendNow = useCallback(async () => {
    const validation = validateNotification(currentNotification);
    if (!validation.isValid) {
      Object.values(validation.errors).forEach(error => {
        addNotification({
          type: 'error',
          message: error,
          duration: 3000,
        });
      });
      return;
    }

    const notificationData = {
      title: currentNotification.body.split('\n')[0] || 'Push Notification',
      body: currentNotification.body,
      imageUrl: currentNotification.imageUrl,
      deepLink: currentNotification.deepLink,
      targetPlatform: currentNotification.targetPlatform,
    };

    const result = await sendNotificationWithValidation(notificationData);
    if (result.success) {
      resetNotification();
    }
  }, [currentNotification, validateNotification, sendNotificationWithValidation, resetNotification, addNotification]);

  // Handle saving notification for later
  const handleSaveForLater = useCallback(() => {
    const validation = validateNotification(currentNotification);
    if (!validation.isValid) {
      Object.values(validation.errors).forEach(error => {
        addNotification({
          type: 'error',
          message: error,
          duration: 3000,
        });
      });
      return;
    }

    saveForLater({
      ...currentNotification,
      title: currentNotification.body.split('\n')[0] || 'Draft Notification',
    });
    
    addNotification({
      type: 'success',
      message: 'Notification saved for later!',
      duration: 2000,
    });
    
    resetNotification();
  }, [currentNotification, validateNotification, saveForLater, resetNotification, addNotification]);

  const handleNotificationChange = useCallback((e, index) => {
    if (editIndex === index) {
      setEditValue(e.target.value);
    } else {
      const notification = stackedNotifications[index];
      if (notification) {
        updateStacked(notification.id, { body: e.target.value });
      }
    }
  }, [editIndex, stackedNotifications, updateStacked]);

  const handleNotificationInfo = useCallback((notification, index) => {
    setDialogAction("info");
    setSelectedNotification(notification);
    setSelectedNotificationIndex(index);
    setDialogOpen(true);
  }, []);

  const handleNotificationSend = useCallback(async (notification, index) => {
    const notificationData = {
      title: notification.title || notification.body?.split('\n')[0] || 'Push Notification',
      body: notification.body || notification.text,
      imageUrl: notification.imageUrl,
      deepLink: notification.deepLink,
      targetPlatform: notification.targetPlatform || 'both',
    };

    const result = await sendNotificationWithValidation(notificationData);
    if (result.success) {
      removeFromScheduled(notification.id);
    }
  }, [sendNotificationWithValidation, removeFromScheduled]);

  const handleNotificationEdit = useCallback((notification, index) => {
    setEditIndex(index);
    setEditValue(notification.text);

  // Save For Later handlers
  useEffect(() => {
    if (activeTab === 'saveForLater') {
      dispatch(fetchSaveForLater());
    }
  }, [dispatch, activeTab]);

  // Filter items based on search term
  const filteredSaveForLaterItems = useMemo(() => {
    if (!searchTerm) return saveForLaterItems;
    
    const lowercaseSearch = searchTerm.toLowerCase();
    return saveForLaterItems.filter(item =>
      item.name?.toLowerCase().includes(lowercaseSearch) ||
      item.category?.toLowerCase().includes(lowercaseSearch) ||
      item.brand?.toLowerCase().includes(lowercaseSearch) ||
      item.sku?.toLowerCase().includes(lowercaseSearch)
    );
  }, [saveForLaterItems, searchTerm]);

  // Handle Save For Later item actions
  const handleRemoveItem = async (itemId) => {
    try {
      await dispatch(removeFromSaveForLaterAPI(itemId)).unwrap();
      setSelectedItems(prev => {
        const newSet = new Set(prev);
        newSet.delete(itemId);
        return newSet;
      });
    } catch (error) {
      console.error('Error removing item:', error);
    }
  };

  const handleMoveToCart = async (item) => {
    try {
      await dispatch(addToCart(item));
      await dispatch(removeFromSaveForLaterAPI(item.id));
    } catch (error) {
      console.error('Error moving to cart:', error);
    }
  };

  const handleMoveToWishlist = async (item) => {
    try {
      await dispatch(addToWishlist(item));
      await dispatch(removeFromSaveForLaterAPI(item.id));
    } catch (error) {
      console.error('Error moving to wishlist:', error);
    }
  };

  const handleBulkAction = async (action) => {
    const itemsToProcess = Array.from(selectedItems);
    
    try {
      switch (action) {
        case 'remove':
          for (const itemId of itemsToProcess) {
            await dispatch(removeFromSaveForLaterAPI(itemId));
          }
          break;
        case 'moveToCart':
          for (const itemId of itemsToProcess) {
            const item = saveForLaterItems.find(i => i.id === itemId);
            if (item) await handleMoveToCart(item);
          }
          break;
        case 'moveToWishlist':
          for (const itemId of itemsToProcess) {
            const item = saveForLaterItems.find(i => i.id === itemId);
            if (item) await handleMoveToWishlist(item);
          }
          break;
      }
      setSelectedItems(new Set());
    } catch (error) {
      console.error('Error performing bulk action:', error);
    }
  };

  const handleUpdateNote = async (itemId) => {
    try {
      await dispatch(updateSaveForLaterNote({ itemId, note: noteText }));
      setEditingNote(null);
      setNoteText('');
    } catch (error) {
      console.error('Error updating note:', error);
    }
  };

  const handleSelectItem = (itemId) => {
    setSelectedItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(itemId)) {
        newSet.delete(itemId);
      } else {
        newSet.add(itemId);
      }
      return newSet;
    });
  };
    setDialogAction("edit");
    setSelectedNotification(notification);
    setSelectedNotificationIndex(index);
    setDialogOpen(true);
  }, []);

  const handleNotificationDelete = useCallback((notification, index) => {
    setDialogAction("delete");
    setSelectedNotification(notification);
    setSelectedNotificationIndex(index);
    setDialogOpen(true);
  }, []);

  const handleEditSave = useCallback(() => {
    if (selectedNotification && editValue.trim()) {
      updateStacked(selectedNotification.id, { 
        body: editValue,
        text: editValue 
      });
    }
    setEditIndex(null);
    setDialogOpen(false);
    setEditValue("");
  }, [selectedNotification, editValue, updateStacked]);

  const handleEditCancel = useCallback(() => {
    setEditIndex(null);
    setDialogOpen(false);
  }, []);

  const handleDeleteConfirm = useCallback(() => {
    if (selectedNotification) {
      removeFromScheduled(selectedNotification.id);
    }
    setDialogOpen(false);
  }, [selectedNotification, removeFromScheduled]);

  const handleDialogCancel = useCallback(() => {
    setDialogOpen(false);
  }, []);

  const handleDialogConfirm = useCallback(() => {
    setDialogOpen(false);
    // Add your action logic here (send, edit, delete, info)
  }, []);

  return (
    <div className="p-4">
      {/* Tab Navigation */}
      <div className="mb-6">
        <div className="border-b border-gray-200">
          <nav className="-mb-px flex space-x-8">
            <button
              onClick={() => setActiveTab('notifications')}
              className={`whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
                activeTab === 'notifications'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
            >
              <Mail className="inline w-4 h-4 mr-2" />
              Push Notifications
            </button>
            <button
              onClick={() => setActiveTab('saveForLater')}
              className={`whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm ${
                activeTab === 'saveForLater'
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
            >
              <Bookmark className="inline w-4 h-4 mr-2" />
              Save For Later ({saveForLaterCount})
            </button>
          </nav>
        </div>
      </div>

      {/* Tab Content */}
      {activeTab === 'notifications' ? (
        <div className="flex flex-col xl:flex-row gap-6">
          {/* Left Column - Form */}
          <div className="flex-1">
            <h2 className="text-lg sm:text-xl font-semibold text-gray-900 mb-4 sm:mb-6">
              Notification
            </h2>

          {/* Notification Text */}
          <div className="mb-4 sm:mb-6">
            <textarea
              value={currentNotification.body}
              onChange={(e) => updateNotification({ body: e.target.value })}
              placeholder="Type Here"
              className="w-3xl h-24 sm:h-32 border border-gray-300 rounded-lg p-3 text-sm resize-none focus:outline-none focus:border-black"
              disabled={isSending}
            />
          </div>

          {/* Notification Image Upload */}
          <div className="mb-4 sm:mb-6">
            <label className="block text-sm font-medium text-gray-900 mb-2">
              Notification image (optional)
            </label>
            {/* Hidden file input for image upload */}
            <input
              type="file"
              accept="image/*"
              ref={fileInputRef}
              style={{ display: "none" }}
              onChange={handleFileChange}
            />
            <button
              type="button"
              className="flex items-center gap-2 bg-blue-500 text-white px-3 sm:px-4 py-2 rounded-lg text-sm hover:bg-blue-600 disabled:opacity-50"
              onClick={handleFileUpload}
              disabled={isUploading}
            >
              <Upload size={16} />
              {isUploading ? 'Uploading...' : 'Upload Image'}
            </button>
            <div className="mt-3 w-12 h-12 border-2 border-dashed border-gray-300 rounded flex items-center justify-center">
              {/* Show uploaded image preview if available */}
              {(currentNotification.image || currentNotification.imageUrl) ? (
                <img
                  src={currentNotification.image || currentNotification.imageUrl}
                  alt="Notification"
                  className="w-10 h-10 object-cover rounded"
                />
              ) : (
                <div className="w-6 h-6 bg-gray-200 rounded"></div>
              )}
            </div>
          </div>

          {/* Deeplink - slightly longer than dropdown */}
          <div className="mb-4 sm:mb-6" style={{ maxWidth: 280 }}>
            <label className="block text-sm font-medium text-gray-900 mb-2">
              Deeplink(optional) eg yoraa/product/123
            </label>
            <input
              type="text"
              value={currentNotification.deepLink}
              onChange={(e) => updateNotification({ deepLink: e.target.value })}
              placeholder="eg yoraa/product/123"
              className="border border-gray-300 rounded-md px-2 py-1 text-xs focus:outline-none focus:border-black bg-white w-44"
              style={{ minWidth: 140 }}
              disabled={isSending}
            />
          </div>

          {/* Custom Target Platform Dropdown - Minimal Style */}
          <div className="mb-4 sm:mb-6 relative" style={{ maxWidth: 180 }}>
            <label className="block text-sm font-medium text-gray-900 mb-2">
              Target platform
            </label>
            <button
              type="button"
              className="border border-gray-200 rounded-md px-2 py-1 text-xs text-left focus:outline-none bg-white w-32 h-8 flex items-center focus:border-black"
              style={{ boxShadow: "none", minWidth: 120 }}
              onClick={handleDropdownToggle}
            >
              {platformDropdownText}
            </button>
            {dropdownOpen && (
              <div
                className="absolute z-10 mt-1 w-32 bg-white border border-gray-200 rounded-md"
                style={{ minWidth: 120 }}
              >
                <div className="py-1">
                  <button
                    type="button"
                    className={`w-full text-left px-3 py-1 text-xs ${
                      currentNotification.targetPlatform === 'both'
                        ? "text-blue-600 bg-gray-100"
                        : "text-gray-900"
                    }`}
                    onClick={() => handlePlatformSelect('both')}
                  >
                    Both
                    {currentNotification.targetPlatform === 'both' && (
                      <span className="ml-2">✓</span>
                    )}
                  </button>
                  {PLATFORM_OPTIONS.map((opt) => (
                    <button
                      key={opt.value}
                      type="button"
                      className={`w-full text-left px-3 py-1 text-xs ${
                        currentNotification.targetPlatform === opt.value
                          ? "text-blue-600 bg-gray-100"
                          : "text-gray-900"
                      }`}
                      onClick={() => handlePlatformSelect(opt.value)}
                    >
                      {opt.label}
                      {currentNotification.targetPlatform === opt.value && (
                        <span className="ml-2">✓</span>
                      )}
                    </button>
                  ))}
                </div>
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row gap-2 sm:gap-4 mb-6 sm:mb-8">
            <button 
              className="text-sm text-gray-600 hover:text-gray-900 px-4 py-2 border border-slate-300 rounded-full disabled:opacity-50"
              onClick={handleSaveForLater}
              disabled={isLoading || isSending || !currentNotification.body.trim()}
            >
              save for later
            </button>
            <button 
              className="bg-black text-white px-6 sm:px-8 py-2 rounded-full text-sm hover:bg-gray-800 disabled:opacity-50"
              onClick={handleSendNow}
              disabled={isLoading || isSending || !currentNotification.body.trim()}
            >
              {isSending ? 'Sending...' : 'Send Now'}
            </button>
          </div>

          {/* Stack notification for later */}
          <div>
            <h3 className="text-base sm:text-lg font-semibold text-gray-900 mb-4 w-full">
              Stack notification for later
            </h3>
            <div className="space-y-4">
              {stackedNotifications.map((notification, index) => (
                <NotificationItem
                  key={notification.id || index}
                  notification={{
                    ...notification,
                    text: notification.body || notification.text,
                    platforms: [notification.targetPlatform || 'both'],
                    deeplink: notification.deepLink,
                  }}
                  onEdit={() => handleNotificationEdit(notification, index)}
                  onDelete={() => handleNotificationDelete(notification, index)}
                />
              ))}
              
              {stackedNotifications.length === 0 && (
                <div className="text-center py-8 text-gray-500">
                  No notifications saved for later
                </div>
              )}
            </div>
            {dialogOpen && (
              <div className="fixed inset-0 z-50 flex items-center justify-center">
                <div
                  className="absolute inset-0 pointer-events-none"
                  style={{ boxShadow: "0 0 0 100vmax rgba(0,0,0,0.12)" }}
                />
                {dialogAction === "edit" ? (
                  <EditNotificationModal
                    value={editValue}
                    onChange={(e) => setEditValue(e.target.value)}
                    onSave={handleEditSave}
                    onCancel={handleEditCancel}
                    original={selectedNotification?.text}
                  />
                ) : dialogAction === "delete" ? (
                  <ConfirmationDialogue
                    open={dialogOpen}
                    message={`Are you sure you want to delete this notification?`}
                    confirmText="Delete"
                    onConfirm={handleDeleteConfirm}
                    onCancel={handleDialogCancel}
                  />
                ) : (
                  <ConfirmationDialogue
                    open={dialogOpen}
                    message={"Are you sure you want to send the notification"}
                    onConfirm={handleDialogConfirm}
                    onCancel={handleDialogCancel}
                  />
                )}
              </div>
            )}
          </div>
        </div>

        {/* Right Column - Preview */}
        <div className="absolute right-10 w-full xl:w-80 h-auto order-first xl:order-last">
          <div className="flex items-center gap-2 mb-4">
            <h3 className="text-base sm:text-lg font-semibold text-gray-900">
              Preview
            </h3>
            {/* Info button navigates to preview page */}
            <button
              className="bg-black rounded-full flex items-center justify-center"
              onClick={handleNavigateToPreview}
              title="See full preview"
            >
              <Info size={24} className="text-white" />
            </button>
          </div>

          <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 flex items-center justify-center">
            <div className="text-center">
              {/* Show uploaded image if available, else show icon */}
              {(currentNotification.image || currentNotification.imageUrl) ? (
                <div className="w-full mx-auto border-2 border-blue-500 rounded-lg flex items-center justify-center overflow-hidden">
                  <img
                    src={currentNotification.image || currentNotification.imageUrl}
                    alt="Notification Preview"
                    className="w-full h-full object-cover rounded-lg"
                  />
                </div>
              ) : (
                <div className="w-12 h-12 sm:w-16 sm:h-16 mx-auto mb-4 border-2 border-blue-500 rounded-lg flex items-center justify-center">
                  <Mail size={24} className="text-blue-500 sm:w-8 sm:h-8" />
                </div>
              )}
              
              {/* Preview notification content */}
              {currentNotification.body && (
                <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                  <p className="text-sm text-gray-800 font-medium">Preview:</p>
                  <p className="text-xs text-gray-600 mt-1">{currentNotification.body}</p>
                  {currentNotification.deepLink && (
                    <p className="text-xs text-blue-600 mt-1">→ {currentNotification.deepLink}</p>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      ) : (
        /* Save For Later Tab Content */
        <div className="space-y-6">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <h2 className="text-2xl font-bold text-gray-900">
              Save For Later ({saveForLaterCount} items)
            </h2>
            
            {/* Search and View Controls */}
            <div className="flex items-center gap-3">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
                <input
                  type="text"
                  placeholder="Search items..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                />
              </div>
              
              <div className="flex items-center gap-2">
                <button
                  onClick={() => setViewMode('grid')}
                  className={`p-2 rounded-lg ${viewMode === 'grid' ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:bg-gray-100'}`}
                >
                  <Grid className="w-4 h-4" />
                </button>
                <button
                  onClick={() => setViewMode('list')}
                  className={`p-2 rounded-lg ${viewMode === 'list' ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:bg-gray-100'}`}
                >
                  <List className="w-4 h-4" />
                </button>
              </div>
            </div>
          </div>

          {/* Bulk Actions */}
          {selectedItems.size > 0 && (
            <div className="bg-blue-50 p-4 rounded-lg flex items-center justify-between">
              <span className="text-sm text-blue-700">
                {selectedItems.size} item{selectedItems.size !== 1 ? 's' : ''} selected
              </span>
              <div className="flex gap-2">
                <button
                  onClick={() => handleBulkAction('moveToCart')}
                  className="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700"
                >
                  <ShoppingCart className="inline w-4 h-4 mr-1" />
                  Move to Cart
                </button>
                <button
                  onClick={() => handleBulkAction('moveToWishlist')}
                  className="px-3 py-1 bg-pink-600 text-white rounded text-sm hover:bg-pink-700"
                >
                  <Heart className="inline w-4 h-4 mr-1" />
                  Move to Wishlist
                </button>
                <button
                  onClick={() => handleBulkAction('remove')}
                  className="px-3 py-1 bg-red-600 text-white rounded text-sm hover:bg-red-700"
                >
                  <Trash2 className="inline w-4 h-4 mr-1" />
                  Remove
                </button>
              </div>
            </div>
          )}

          {/* Items Grid/List */}
          {saveForLaterLoading ? (
            <div className="flex justify-center items-center py-12">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
            </div>
          ) : filteredSaveForLaterItems.length === 0 ? (
            <div className="text-center py-12">
              <Package className="mx-auto h-12 w-12 text-gray-400 mb-4" />
              <h3 className="text-lg font-medium text-gray-900 mb-2">No items saved for later</h3>
              <p className="text-gray-500">Items you save for later will appear here.</p>
            </div>
          ) : (
            <div className={viewMode === 'grid' 
              ? "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6"
              : "space-y-4"
            }>
              {filteredSaveForLaterItems.map((item) => (
                <div key={item.id} className={viewMode === 'grid' 
                  ? "bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow"
                  : "bg-white rounded-lg shadow-md p-4 flex items-center gap-4"
                }>
                  {viewMode === 'grid' ? (
                    <>
                      <div className="relative">
                        <img
                          src={item.image || '/placeholder-image.jpg'}
                          alt={item.name}
                          className="w-full h-48 object-cover"
                        />
                        <div className="absolute top-2 left-2">
                          <input
                            type="checkbox"
                            checked={selectedItems.has(item.id)}
                            onChange={() => handleSelectItem(item.id)}
                            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                          />
                        </div>
                        <div className="absolute bottom-2 left-2 bg-blue-600 text-white px-2 py-1 rounded text-xs">
                          Saved {new Date(item.savedAt).toLocaleDateString()}
                        </div>
                      </div>
                      
                      <div className="p-4">
                        <h3 className="font-semibold text-lg mb-2 line-clamp-2">{item.name}</h3>
                        <div className="flex items-center gap-1 mb-2">
                          <Star className="w-4 h-4 fill-yellow-400 text-yellow-400" />
                          <span className="text-sm text-gray-600">4.5 (120 reviews)</span>
                        </div>
                        <div className="flex items-center justify-between mb-3">
                          <div className="text-lg font-bold text-green-600">₹{item.price}</div>
                          <div className="text-sm text-gray-500">{item.category}</div>
                        </div>

                        {/* Action Buttons */}
                        <div className="flex gap-2">
                          <button
                            onClick={() => handleMoveToCart(item)}
                            className="flex-1 bg-blue-600 text-white py-2 px-3 rounded text-sm hover:bg-blue-700"
                          >
                            <ShoppingCart className="inline w-4 h-4 mr-1" />
                            Add to Cart
                          </button>
                          <button
                            onClick={() => handleMoveToWishlist(item)}
                            className="p-2 border border-gray-300 rounded hover:bg-gray-50"
                          >
                            <Heart className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => handleRemoveItem(item.id)}
                            className="p-2 border border-gray-300 rounded hover:bg-gray-50 text-red-500"
                          >
                            <Trash2 className="w-4 h-4" />
                          </button>
                        </div>
                      </div>
                    </>
                  ) : (
                    <>
                      <input
                        type="checkbox"
                        checked={selectedItems.has(item.id)}
                        onChange={() => handleSelectItem(item.id)}
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                      />
                      <img
                        src={item.image || '/placeholder-image.jpg'}
                        alt={item.name}
                        className="w-16 h-16 object-cover rounded"
                      />
                      <div className="flex-1">
                        <h3 className="font-semibold text-lg">{item.name}</h3>
                        <p className="text-gray-600">{item.category}</p>
                        <p className="text-green-600 font-bold">₹{item.price}</p>
                      </div>
                      <div className="flex gap-2">
                        <button
                          onClick={() => handleMoveToCart(item)}
                          className="bg-blue-600 text-white py-2 px-3 rounded text-sm hover:bg-blue-700"
                        >
                          Add to Cart
                        </button>
                        <button
                          onClick={() => handleMoveToWishlist(item)}
                          className="p-2 border border-gray-300 rounded hover:bg-gray-50"
                        >
                          <Heart className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => handleRemoveItem(item.id)}
                          className="p-2 border border-gray-300 rounded hover:bg-gray-50 text-red-500"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </div>
                    </>
                  )}
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default PushNotification;
